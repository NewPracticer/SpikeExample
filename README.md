# SpikeExample

## 介绍
构建秒杀相关内容。项目包含三个模块：
1. 注册登录。
2. 商品详情模块。
3. 下单交易模块.
4. 限流削峰模块
5. 秒杀模块

## 注册 登录 查询商品详情迭代流程
1. 优化tomcat
    1. spring-configuration-metadata.json文件下，有tomcat相关配置，可修改相关配置增加tomcat的并发量
        1. spring-tomcat-accept-count:默认长度为100 等待队列长度
        2. spring-tomcat-max-connection：最大可连接数，默认为10000
        3. spring.tomcat.max-threads:最大工作线程数。默认200
        4. spring.tomcat.min-spare-threads:最小工作线程数，默认为10 
    2.  自定义WebServerConfiguration 
    3.  目前局限：
        1. 不能过分提高进程调度线程数。因为提高的越多，就会花费很多时间在CPU调度上。
        2. 目前局限：等待队列长度不能无限长，消耗内存，出队入库也耗内存。
2. 增加nginx，实现横向扩容 =》 静态资源配置nginx服务器上，通过指定路径访问（如注册页面，商品详情页面）
    1.  设置upstream server
    2.  设置动态请求为proxy pass 路径
3. 使用redis 实现分布式会话，前期使用tomcat容器的session，后期考虑app，小程序等使用token
4. 增加本地缓存Guava
5. 使用nginx 增加 lua缓存(lua语法是关键)=》 openrestry 配合redis 进行网络缓存 =》 引入静态资源CDN =》全局静态资源CDN。

## 下单交易迭代流程
1. 下单后，去缓存中扣减库存
    1. 若无库存，则标记为售罄
    2. 若有库存，则扣减
        1. 异步发送消息到rocketmq，同时订阅相应topic进行消费，进行数据库扣减
2. 新增库存流水表。
    1. 下单后，发送事务消息到rocketmq。
        1. 当事务成功时，去创建订单，扣减库存。
        2. 当事务回滚时，设置库存流水表状态。
        3. 当事务还未发生时，则通过内部回调方法，进行check，根据库存流水表进行检验
3. 创建订单前，redis中对对应的商品的设置是否售罄的状态，进行削流。

### 局限
1. 交易验证完全依赖数据库
2. 库存行锁
### 优化
1. 交易验证部分
    1. 用户校验部分进行缓存。
    2. 活动校验部分：
        1. 引入整体活动发布流程，提前时间发布
        2. 活动部分进行缓存
2. 库存行锁部分
    1. 扣减库存缓存（只有这两步，若缓存发生异常，则会出现数据库记录与缓存不一致的情况）
        1. 活动发布同步库存进缓存
        2. 下单交易减缓存库存
    2. 异步同步数据库（使用消息中间件，实现最终一致性）
        1. 扣减操作执行失败 
        2. 异步消息发送失败 
        3. 下单失败无法正确回补库存
## 秒杀流程
### 局限
1. 秒杀下单接口会被脚本不停的刷新
2. 秒杀验证逻辑部分复杂，对交易产生无关联的负载
3. 存在可能有无限多用户参加秒杀活动
### 优化
1. 引入秒杀令牌，秒杀接口需要依靠令牌才能进入
2. 秒杀的令牌由秒杀活动模块负责生成，秒杀活动模块对秒杀令牌生成全权处理
3. 设置能获得秒杀令牌的用户的数量
4. 使用线程池作为拥塞窗口，进行队列泄洪

## 防刷限流
1. 加入验证码
2. 使用限流工具
3. 根据设备唯一码作为交易凭证，防止黄牛刷单

    